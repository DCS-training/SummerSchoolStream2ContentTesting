distillery <- c(distillery, rep(Namedist[[i]], length(Namebottle[[i]])))
bottles <- c(bottles, b)
}
}
# Initialize empty vectors to store the data
list_indices <- c()
sublist_indices <- c()
content <- c()
# Initialize empty vectors to store the data
list_indices <- c()
sublist_indices <- c()
content <- c()
# Loop through the list and its sublists
for (i in seq_along(Namebottle)) {
for (j in seq_along(Namebottle[[i]])) {
list_indices <- c(list_indices, i)
sublist_indices <- c(sublist_indices, j)
content <- c(content, my_list[[i]][[j]])
}
}
# Initialize empty vectors to store the data
list_indices <- c()
sublist_indices <- c()
content <- c()
# Loop through the list and its sublists
for (i in seq_along(Namebottle)) {
for (j in seq_along(Namebottle[[i]])) {
list_indices <- c(list_indices, i)
sublist_indices <- c(sublist_indices, j)
content <- c(content, Namebottle[[i]][[j]])
}
}
# Combine the vectors into a dataframe
bottles <- data.frame(List = list_indices, Sublist = sublist_indices, Content = content)
View(bottles)
# Initialize empty vectors to store the data
list_indices <- c()
sublist_indices <- c()
content <- c()
# Loop through the list and its sublists
for (i in seq_along(Namedist)) {
for (j in seq_along(Namedist[[i]])) {
list_indices <- c(list_indices, i)
sublist_indices <- c(sublist_indices, j)
content <- c(content, Namedist[[i]][[j]])
}
}
# Combine the vectors into a dataframe
distilleries <- data.frame(List = list_indices, Sublist = sublist_indices, Content = content)
View(distilleries)
# Combine the vectors into a dataframe
bottles <- data.frame(List = list_indices, Sublist = sublist_indices, bottlename = content)
# Combine the vectors into a dataframe
distilleries <- data.frame(List = list_indices, Sublist = sublist_indices, distName = content)
bottleAndDist<- merge(bottles, distilleries, by = "List", all.x = TRUE)[, c("bottlename", "distName")]
bottleAndDist<- merge(bottles, distilleries, by = "List", all.y = TRUE)[, c("bottlename", "distName")]
View(bottleAndDist)
bottleAndDist<- merge(bottles, distilleries, by = "List", all.y = TRUE)
bottleAndDist<- merge(bottles, distilleries, by = "List", all.x = TRUE)
# Loop through the list and its sublists
for (i in seq_along(Namebottle)) {
for (j in seq_along(Namebottle[[i]])) {
list_indices <- c(list_indices, i)
sublist_indices <- c(sublist_indices, j)
content <- c(content, Namebottle[[i]][[j]])
}
}
# Combine the vectors into a dataframe
bottles <- data.frame(List = list_indices, Sublist = sublist_indices, bottlename = content)
bottleAndDist<- merge(bottles, distilleries, by = "List", all.x = TRUE)
bottleAndDist<- merge(bottles, distilleries, by = "List", all.x = TRUE)[,c("bottlename","distName")]
LinkReview <- map(DistilleriesList, get.review.links)
head(LinkReview)
length(LinkReview)
# So we need to use the flatten function to deal with this
LinkReviewFlat <-LinkReview%>%
flatten()
length(LinkReviewFlat)
LinkReview <-unlist(LinkReviewFlat)
gc()
gc()
# GetAge ===================
get.age <- function(x){
links <- read_html(x) %>%
html_nodes('td:nth-child(4)') %>%
html_text
}
Age <- map(DistilleriesList, get.age)
head(Age)
length(Age)
# So we need to use the flatten function to deal with this
AgeFlat <-Age%>%
flatten()
length(AgeFlat)
BottleAge<-unlist(AgeFlat)
# Strength ===================
get.strength <- function(x){
links <- read_html(x) %>%
html_nodes('td:nth-child(5)') %>%
html_text
}
Strength <- map(DistilleriesList, get.strength)
head(Strength)
length(Strength)
# So we need to use the flatten function to deal with this
StrengthFlat <-Strength%>%
flatten()
length(StrengthFlat)
StrengthBottle<-unlist(StrengthFlat)
# YEar===================
get.year <- function(x){
links <- read_html(x) %>%
html_nodes('td:nth-child(6)') %>%
html_text
}
Year <- map(DistilleriesList, get.year)
head(Year)
length(Year)
# So we need to use the flatten function to deal with this
YearFlat <-Year%>%
flatten()
length(YearFlat)
YearBottle<-unlist(YearFlat)
# Rating===================
get.rating <- function(x){
links <- read_html(x) %>%
html_nodes('td:nth-child(8)') %>%
html_text
}
RatingB<- map(DistilleriesList, get.rating)
head(RatingB)
length(RatingB)
# So we need to use the flatten function to deal with this
RatingBFlat <-RatingB%>%
flatten()
length(RatingBFlat)
RatingBottle<-unlist(RatingBFlat)
test2<-head(LinkReview,1000)
# Rating===================
get.review <- function(x){
links <- read_html(x) %>%
html_nodes('.wb--free-text') %>%
html_text
}
Review<- map(test2, get.review)
test2<-head(LinkReview,500)
# Rating===================
get.review <- function(x){
links <- read_html(x) %>%
html_nodes('.wb--free-text') %>%
html_text
}
Review<- map(test2, get.review)
test2[159]
get.review <- function(x){
# Use tryCatch to handle errors
tryCatch({
links <- read_html(x) %>%
html_nodes('.wb--free-text') %>%
html_text()
return(links)
}, error = function(e) {
# If an error occurs (e.g., bad link), return NA
return(NA)
})
}
Review<- map(test2, get.review)
View(Review)
Review<- map(LinkReview, get.review)
test2<-LinkReview[,1:60000]
test2<-LinkReview[1:60000,]
test2<-LinkReview[1:60000]
Review<- map(test2, get.review)
test2<-LinkReview[1:10000]
Review<- map(test2, get.review)
test2<-LinkReview[1:5000]
Review<- map(test2, get.review)
View(bottles)
# Identify duplicate rows based on the first two columns
duplicate_rows <- duplicated(bottles[, c("List", "Sublist")])
# Subset the original dataset to remove duplicate rows
new_dataset <- original_dataset[!duplicate_rows, ]
# Subset the original dataset to remove duplicate rows
new_dataset <- bottles[!duplicate_rows, ]
View(new_dataset)
unlist_with_null <- function(x) {
if (length(x) == 0) {
return(NULL)
} else {
return(unlist(x))
}
}
# Function to unlist and handle empty lists
unlist_with_null <- function(x) {
if (length(x) == 0) {
return(NULL)
} else {
return(unlist(x))
}
}
# Apply the function to each element of the list
new_list <- lapply(Age, unlist_with_null)
# Apply the function to each element of the list
new_list <- lapply(AgeFlat, unlist_with_null)
# Subset the original dataset to remove duplicate rows
bottlesClean <- bottles[!duplicate_rows, ]
ottleAndDist<- merge(bottlesClean, distilleries, by = "List", all.x = TRUE)[,c("bottlename","distName")]
bottleAndDist<- merge(bottlesClean, distilleries, by = "List", all.x = TRUE)[,c("bottlename","distName")]
unlist_with_null <- function(x) {
if (length(x) == 0) {
return(NULL)
} else {
return(unlist(x))
}
}
# Apply the function to each element of the list
LinkReview<- lapply(LinkReviewFlat, unlist_with_null)
# Apply the function to each element of the list
LinkReview<- lapply(LinkReviewFlat, unlist_with_null)
# Apply the function to each element of the list
BottleAge <- lapply(AgeFlat, unlist_with_null)
# Function to unlist and handle empty lists
unlist_with_null <- function(x) {
if (length(x) == 0) {
return(NULL)
} else {
return(unlist(x))
}
}
# Apply the function to each element of the list
BottleAge <- lapply(AgeFlat, unlist_with_null)
# Function to unlist and handle empty lists
unlist_with_null <- function(x) {
if (length(x) == 0) {
return(NULL)
} else {
return(unlist(x))
}
}
# Apply the function to each element of the list
BottleAge <- lapply(AgeFlat, unlist_with_null)
# Apply the function to each element of the list
BottleAge <- lapply(Age, unlist_with_null)
# Apply the function to each element of the list
BottleAge <- lapply(AgeFlat, unlist_with_null)
View(bottleAndDist)
View(bottles)
View(bottlesClean)
extract_values <- function(index, sublist) {
n <- length(sublist)
indices <- rep(index, n)
list(indices, seq_along(sublist), unlist(sublist))
}
# Use Map to apply the function to each sublist
result <- Map(extract_values, seq_along(Namebottle), Namebottle)
# Combine the result into a dataframe
final_dataset <- do.call(rbind, result)
colnames(final_dataset) <- c("List", "Sublist", "Content")
# Flatten the list of lists, retaining original indices
flattened_list <- unlist(Namebottle, recursive = FALSE)
# Get the indices for each element in the flattened list
indices <- unlist(lapply(seq_along(Namebottle), function(i) rep(i, length(Namebottle[[i]]))))
# Create a dataframe from the indices and flattened list
result <- data.frame(
List = indices,
Sublist = sequence(sapply(Namebottle, length)),
Content = unlist(flattened_list)
)
# Print the result
print(result)
View(result)
# Replace NULL sublists with a placeholder value
Namebottle <- lapply(Namebottle, function(x) if (is.null(x)) NA else x)
# Flatten the list of lists, retaining original indices
flattened_list <- unlist(Namebottle, recursive = FALSE)
# Get the indices for each element in the flattened list
indices <- unlist(lapply(seq_along(Namebottle), function(i) rep(i, length(Namebottle[[i]]))))
# Create a dataframe from the indices and flattened list
result <- data.frame(
List = indices,
Sublist = sequence(sapply(Namebottle, length)),
Content = unlist(flattened_list)
)
View(result)
# Replace NULL sublists with a placeholder value
Namebottle <- lapply(Namebottle, function(x) if (is.null(x)) NA else x)
# Flatten the list of lists, retaining original indices
flattened_list <- unlist(Namebottle, recursive = FALSE)
# Get the indices for each element in the flattened list
indices <- unlist(lapply(seq_along(Namebottle), function(i) rep(i, length(Namebottle[[i]]))))
# Create a dataframe from the indices and flattened list
result <- data.frame(
List = indices,
Sublist = sequence(sapply(Namebottle, length)),
Content = unlist(flattened_list)
)
UnlistedNamebottle<-unlist(Namebottle)
UnlistedNamebottle<-unlist(Namebottle)
Namebottle
# Flatten the list of lists, retaining original indices
flattened_list <- unlist(Namebottle, recursive = FALSE)
# Get the indices for each element in the flattened list
indices <- unlist(lapply(seq_along(Namebottle), function(i) rep(i, length(Namebottle[[i]]))))
# Create a dataframe from the indices and flattened list
result <- data.frame(
List = indices,
Sublist = sequence(sapply(Namebottle, length)),
Content = unlist(flattened_list)
)
# Print the result
print(result)
View(result)
# Flatten the list of lists, retaining original indices
flattened_list <- unlist(Namebottle, recursive = FALSE)
# Replace empty lists with NULL
flattened_list[sapply(Namebottle, length) == 0] <- NA
# Flatten the list of lists, retaining original indices
flattened_list <- unlist(Namebottle, recursive = FALSE)
# Replace empty lists with NULL
flattened_list[sapply(Namebottle, length) == 0] <- NA
# Get the indices for each element in the flattened list
indices <- unlist(lapply(seq_along(Namebottle), function(i) rep(i, length(Namebottle[[i]]))))
# Create a dataframe from the indices and flattened list
result <- data.frame(
List = indices,
Sublist = sequence(sapply(Namebottle, length)),
Content = unlist(flattened_list)
)
# Function to extract indices and values from a sublist
extract_values <- function(index, sublist) {
if (length(sublist) == 0) {
sublist <- NA
}
n <- length(sublist)
indices <- rep(index, n)
list(indices, seq_along(sublist), unlist(sublist))
}
# Function to extract indices and values from a sublist
extract_values <- function(index, sublist) {
if (length(sublist) == 0) {
sublist <- NA
}
n <- length(sublist)
indices <- rep(index, n)
list(indices, seq_along(sublist), unlist(sublist))
}
# Use Map to apply the function to each sublist
result <- Map(extract_values, seq_along(Namebottle),Namebottle)
# Combine the result into a dataframe
final_dataset <- do.call(rbind, result)
final_dataset <- as.data.frame(final_dataset)
colnames(final_dataset) <- c("List", "Sublist", "Content")
# Print final_dataset
print(final_dataset)
# Use Map to apply the function to each sublist
result <- Map(extract_values, seq_along(Namebottle),Namebottle)
# Combine the result into a dataframe
final_dataset <- do.call(rbind, result)
final_dataset <- as.data.frame(final_dataset)
colnames(final_dataset) <- c("List", "Sublist", "Content")
# Create a function to extract indices and values from a sublist
extract_values <- function(index, sublist) {
n <- length(sublist)
if (n == 0) {
return(list(index, NA, NA))
} else {
indices <- rep(index, n)
return(Map(c, indices, seq_along(sublist), sublist))
}
}
# Use Map to apply the function to each sublist
result <- unlist(Map(extract_values, seq_along(Namebottle), Namebottle), recursive = FALSE)
# Combine the result into a dataframe
final_dataset <- do.call(rbind, result)
final_dataset <- as.data.frame(final_dataset)
colnames(final_dataset) <- c("List", "Sublist", "Content")
gc()
rm(list = ls())
gc()
close(file_connection)
gc()
gc()
## 1.2. Load the data------------
Parish <- read_csv("Day2/data/Parishes.csv")
library(quanteda)
library(tidyverse)
library(quanteda.textstats)
library(quanteda.textmodels)
library(quanteda.textplots)
library(tm)
library(topicmodels)
library(syuzhet)
library(RColorBrewer)
## 1.2. Load the data------------
Parish <- read_csv("Day2/data/Parishes.csv")
## 2.3. Extract the text column ------
# We'll work with the UK data first, and then you'll repeat the process with the Scotland data on your own later in this block.
# Subset the text column and save it as an object:
ParishText<-Parish$text
# Prepare the data for analysis, creating and cleaning a tm Corpus object:
ParishCorpus <- VCorpus(VectorSource(ParishText))# transform our data set in a corpus
ParishCorpus<- tm_map (ParishCorpus, content_transformer(tolower))# remove capitalised letters
ParishCorpus <- tm_map (ParishCorpus, removePunctuation)# remove punctuation
ParishCorpus<- tm_map (ParishCorpus, removeWords, stopwords('english')) # remove English stopwords
ParishCorpus <- tm_map (ParishCorpus, removeWords, c('s', 't', '@\\w+', 'http.+ |http.+$','amp')) # remove specific words/symbols
ParishCorpus<- tm_map (ParishCorpus, removeNumbers)# remove numbers
ParishCorpus <- tm_map (ParishCorpus, stripWhitespace) # remove multiple white spaces
# 3. Topic Modelling=================================
## 3.1. Create a document term matrix (dtm) of the corpus------
# A DTM is a mathematical matrix that describes the frequency of terms that occur in a collection of documents.
# Rows correspond to documents in the collection and columns correspond to terms.
LdaDtmParish <- DocumentTermMatrix(ParishCorpus)
gc()
gc()
gc()
gc()
## 3.4. Create a term frequency matrix --------------
LdaDtmParishMx<- as.matrix(LdaDtmParish)
## 3.5. LDA topic modelling-------------------------------------
### 3.5.1. Create a matrix k 5--------------
#Create a matrix for LDA analsyis, defining the number of topics (k=5)
P_lda <- LDA(LdaDtmParish, k=5, control=list(seed=1234))
View(LdaDtmParish)
# Remove rows with all zero values
LdaDtmParish_processed <- LdaDtmParish[rowSums(LdaDtmParish != 0) > 0, ]
LdaDtmParish_matrix <- as.matrix(LdaDtmParish)
library(syuzhet)
library(vader)
library(tidyverse)
library(wordcloud)
library(tm)
# Import the dataset
whiskyReview1<-read_csv("Day3/export/data/ReviewWithDistilleriesInfo.csv")
wiskyReview2<-read_csv("Day1/DataWrangling/Data/scotch_review_manual_clean.csv")
View(wiskyReview2)
Whisky1 <- whiskyReview1$Reviews %>%
lapply(get_vader)
#our full dataset are too big so we are going to work on a subset
whiskyReview1S<-sample_n(whiskyReview1, 300, set.seed=1234)
## 2.2. Calculate sentiment scores with VADER --------
Whisky1 <- whiskyReview1S$Reviews %>%
lapply(get_vader)# lapply= apply across the data set
library(parallel)
library(doParallel)
install.packages(doParallel)
install.packages("doParallel")
library(doParallel)
# Initialize a cluster with desired number of workers
cl <- makeCluster(4, type = 'PSOCK', outfile = '')
# Register the cluster for parallel computation
registerDoParallel(cl)
result <- foreach(review = Whisky1) %dopar% {
get_vader(review)
}
## 2.2. Calculate sentiment scores with VADER --------
Whisky1 <- whiskyReview1S$Reviews
# Apply the function get_vader in parallel
result <- foreach(review = Whisky1) %dopar% {
get_vader(review)
}
library(vader)
result <- foreach(review = Whisky1) %dopar% {
get_vader(review)
}
# Apply the function get_vader in parallel
result <- foreach(review = Whisky1) %dopar% {
Vader::get_vader(review)
}
vader::get_vader(review)
# Stop the cluster
stopCluster(cl)
# Combine the results if needed
combined_result <- do.call(rbind, result)
# Apply the function get_vader in parallel
result <- foreach(review = Whisky1) %dopar% {
vader::get_vader(review)
}
# Initialize a cluster with desired number of workers
cl <- makeCluster(4, type = 'PSOCK', outfile = '')
# Register the cluster for parallel computation
registerDoParallel(cl)
# Apply the function get_vader in parallel
result <- foreach(review = Whisky1) %dopar% {
vader::get_vader(review)
}
library(foreach)
library(doParallel)
library(Vader)
library(vader)
# Initialize a cluster
cl <- makeCluster(detectCores())  # Use all available cores
registerDoParallel(cl)
# Apply sentiment analysis in parallel
result <- foreach(review = whiskyReview1S$Reviews) %dopar% {
get_vader(review)
}
# Initialize a cluster
cl <- makeCluster(detectCores())  # Use all available cores
registerDoParallel(cl)
# Apply sentiment analysis in parallel
result <- foreach(review = whiskyReview1S$Reviews) %dopar% {
vader::get_vader(review)
}
install.packages("brms")
library(brms)
install.packages("bayesplot")
detach("package:brms", unload = TRUE)
install.packages("bayesplot")
install.packages("bayesplot")
install.packages("extraDistr")
library(extraDistr)
library(bayesplot)
