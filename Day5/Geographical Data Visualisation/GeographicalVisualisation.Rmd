---
title: "Geographical Data Visualisation"
author: "Ki Tong"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setting up 

Below is the setting up for this class (install packages, mount packages, import data)

#### Install Packages
Libraries we need to install (remember to uncomment before running)
```{r Install}
#install.packages("tmap")
#install.packages("adehabitatHR")

```

#### Load Libraries
Load the packages we need
```{r load}
library(rgdal)
library(rgeos)
library(sp)
library(tmap)
library(dplyr)
library(RColorBrewer)
library(classInt)
library(maptools)
library(png)
library(raster)
library(adehabitatHR)
library(tmaptools)
```


#### Import Data
Import the data that we will need 

First the CSV that we cleaned on Monday and used Tuesday for text analysis 
```{r csv}

Parish <- read_csv("data/parish.csv")
summary(Parish)
```
Then we import the first GeoPackage. 
A GeoPackage is an open, standards-based format designed for the efficient storage, transfer, and exchange of geospatial data. Developed by the Open Geospatial Consortium (OGC), it serves as a container for various types of geospatial information, including vector features, raster maps, and attribute data, all within a single file https://www.geopackage.org/.

```{r Gpkg1 }
ParishesGeo <- readOGR(dsn = "data/Spatial/Parishes.gpkg")
plot(ParishesGeo, main = "Scottish Parishes")
```

You can also change the basic format of the symbols
```{r Gpkg2 }
plot(ParishesGeo,
     col = "black",
     lwd = 1,
     border = "white",
     main = "Scottish Parishes")
```

Change the colors
```{r Gpkg3 }
plot(ParishesGeo,
     col = "black",
     lwd = 1,
     border = "white",
     main = "Scottish Parishes")
```

Load geospatial information for the location of distilleries
```{r Gpkg4}
PointsDistilleries<- readOGR(dsn = "data/Spatial/ScottishDistilleries.gpkg")
plot(PointsDistilleries, main = "Scottish Parishes")
```
But this would only contain info from our Geopackage to add the info from the parish dataset we need to merge the geopackage with it 

## Work on Illness Mentions 


### Extract Informations from the textual data

We will have to do similar steps to those that we take on Tuesday when we were working on the Keywords in context 

The first topic we are going to look at is Illness. So we are creating a new variable that would contain yes if the text contains one of the keywords or no if it does not 

1.Search keywords
```{r }
Parish$Ilness<- ifelse(grepl("ill|ilness|sick|cholera|smallpox|plague|cough|typhoid|fever|measles|dysentery", Parish$text,
                             ignore.case = T), "yes","no")
```

2. Group by Illness and geographical area
```{r }
IlnessGroup <- Parish %>%
  group_by(Area) %>%
  summarise(Total = n(),
            count = sum(Ilness == "yes")) %>%
  mutate(per = round(count/Total, 2))
```

3.Merge the two datasets
```{r }
MergedGeo <-merge(ParishesGeo,IlnessGroup,
                  by.x="JOIN_NAME_",
                  by.y="Area",
                  all.x = TRUE) # nb this is left join cause I want to preserve all the records present in ParishGeo
```

4.Check data to have merged properly
```{r }
head(MergedGeo, max.level = 2)
```


### Visualise the new dataset 

1.Create a continuous color palette
```{r }
color.palette <- colorRampPalette(c("white", "red"))
```

2. Plot using ssplot
```{r }
spplot(MergedGeo,
       "per",
       col.regions = color.palette(100),
       main = "Ilness Report",
       key.space = "right",
       scales = list(draw = TRUE))

```

### Work with map colours
We have an issue with the colour white because some polygons have missing values rather small percentage.
We can fix this by using tm_shape instead of ssplot 
```{r }
tm_shape(MergedGeo) +
  tm_fill("per", style = "quantile", palette = color.palette(100), colorNA = "grey") +
  tm_borders(col = "black")+
  tm_layout(title = "Illness report", legend.text.size = 0.75, legend.title.size = 1.5, frame = FALSE)
```

Let's try changing the colour of the filled regions using predifined colours.
There are predifined colour palettes you can use directly. Commonly used palettes include: rainbow(), heat.colors(), topo.colors(), and terrain.colors()
Beware of the representation of colours. You might need to reverse the colour band to make the representations more intuitive
```{r }
spplot(MergedGeo,
       "per",
       col.regions = rev(heat.colors(100)),
       main = "Ilness Report",
       key.space = "right",
       scales = list(draw = TRUE))
```

You could also change the colour using RColorBrewer
```{r }
display.brewer.all()
color.palette <- brewer.pal(n = 9, name = "YlOrRd")
```

Replot using the new palette
```{r }
spplot(MergedGeo, 
       "per", 
       cuts = 8,
       col.regions = color.palette,
       main = "Ilness Report",
       sp.layout = list("sp.polygons", MergedGeo, col = "black"),
       scales = list(draw = TRUE))

```
### Exercise 

Try to re-plot the map using a different colour range 
Add your code below 
```{r }

```

### Work on the legend intervals 
Change the spacing of the interval.
You can use classInt to make custom cuts if you don't want evenly spaced cutoffs between colors
```{r }
breaks <- classIntervals(MergedGeo$per, n = 5, style = "equal")
breakpoints <- breaks$brks
spplot(MergedGeo, 
       "per", 
       col.regions = color.palette, #Removed (100)
       colorkey = list(at = breakpoints)
)

```

Style could also be adjusted based on quantile and at different 'cuts'

### Exercise 
Try adjusting these values and explore the effects
Write your code below
```{r }

```

## Now we can work on a different subject: Witches 

The steps are always the same first we need to search keywords and then we merge the results with our map of Scotland

### Preparing the dataset
```{r }
Parish$witches<- ifelse(grepl("witch|spell|witches|enchantemt|magic", Parish$text, ignore.case = T), "yes","no")
```

Can you think to other keywords? just add them to the code above. 

Then we group by
```{r }
WitchGroup <- Parish %>%
  group_by(Area) %>%
  summarise(Total = n(), count = sum(witches == "yes")) %>%
  mutate(per = round(count / Total, 2))

```

And finally we merge
```{r }
MergedGeo2 <-merge(ParishesGeo,WitchGroup, by.x="JOIN_NAME_", by.y="Area", all.x = TRUE)# nb this is left join cause I want to preserve all the records present in ParishGeo
```

Let's create a more "witchy" Palette
```{r }
color.palette2 <- colorRampPalette(c("white", "purple"), alpha = 0.5)
```


### Plot the result
```{r }
spplot(MergedGeo2,
       "per",
       col.regions = color.palette2(100),
       main = "Witches Reports",
       key.space = "right",
       scales = list(draw = TRUE),
)
```

### Refine the results:Adding scale bar and north arrow

1. Check dimensions of the boundary box to help guide where to put the labels
```{r }
MergedGeo2@bbox 
```

2. Design a Scale Bar 
```{r }
scalebar1 <- list("SpatialPolygonsRescale", layout.scale.bar(), scale = 100000, fill = c("transparent", "black"), offset = c(50000, 1100000))

text1 <- list("sp.text", c(50000, 1120000), "0km", cex = 0.7)
text2 <- list("sp.text", c(150000, 1120000), "25km", cex = 0.7)
```

3. Define a north arrow
```{r }
arrow <- list("SpatialPolygonsRescale", layout.north.arrow(), offset = c(50000, 1150000), scale = 45000)
```

4. Now we can add all to the map
```{r }
spplot(MergedGeo2,
       "per", 
       col.regions = color.palette2(100),
       sp.layout = list(scalebar1, text1, text2, arrow),
       scales = list(draw = TRUE))

```

## Alchool consumption 
Let's connect back to the one of the main topics of this week and look at alchool consumption across Scotland.

Unsurprisingly the first steps remain the same 

1. Search the keywords
```{r }
Parish$Booze<- ifelse(grepl("illicit still|illicit distillery|drunk|intemperance|wisky|whisky|whiskey|whysky |alembic",Parish$text, ignore.case = T), "yes","no")
```

2. Group by the new column and area
```{r }
BoozeGroup <- Parish %>%
  group_by(Area) %>%
  summarise(Total = n(), count = sum(Booze == "yes")) %>%
  mutate(per = round(count / Total, 2))

```

3. Merge back 
```{r }
MergedGeo3 <-merge(ParishesGeo,BoozeGroup, by.x="JOIN_NAME_", by.y="Area",all.x = TRUE)# nb this is left join cause I want to preserve all the records present in ParishGeo

```

4. Create a Palette
```{r }
color.palette3 <- colorRampPalette(c("white", "Brown"))

```

5. Plot with ssplot
```{r }
spplot(MergedGeo3,
       "per",
       col.regions = color.palette3(100),
       main = "Booze Reports",
       key.space = "right",
       scales = list(draw = TRUE))

```

### Work with multiple datasets 

Add the second dataset i.e. the punctual datasetwith the location of the modern day distilleries
```{r }
spplot(MergedGeo3,
       "per", 
       col.regions = color.palette3(100),
       main = "Booze Reports",
       key.space = "right",
       sp.layout = list("sp.polygons",
                        PointsDistilleries,
                        col = "black", pch = 16, labels = PointsDistilleries$Name),
       scales = list(draw = TRUE))
```

pch controls the symbology of point data. Here are the most common ones: 
pch = 1: Circle (default); pch = 2: Triangle point up; pch = 3: Plus sign; pch = 4: Cross; pch = 5: Diamond; pch = 6: Square; pch = 7: Cross rotated 45 degrees; pch = 8: Asterisk; pch = 9: Circle filled; pch = 10: Triangle point up filled

Try changing the symbology to a different style, you could also adjust the size using cex
```{r }
spplot(MergedGeo3,
       "per", 
       col.regions = color.palette3(100),
       main = "Booze Reports",
       key.space = "right",
       sp.layout = list("sp.polygons",
                        PointsDistilleries,
                        col = "black", pch = 16, labels = PointsDistilleries$Name, cex = 1),
       scales = list(draw = TRUE))
```

### Density Plot with R 
Density visualisation using KDE

KDE for PointsDistilleries
```{r }
kde.output <- kernelUD(PointsDistilleries, h="href", grid = 1000)
plot(kde.output)
```

Convert output to raster
```{r }
kde <- raster(kde.output)
```

sets projection to British National Grid
```{r }
projection(kde) <- CRS("+init=EPSG:27700") # please proceed even though it doesn't work. 
```

skewed values make it difficult to represent, check if rescale is needed
```{r }
summary(kde$ud)
min_ud <- cellStats(kde, stat = 'min')
max_ud <- cellStats(kde, stat = 'max')
if (max_ud - min_ud < 1e-9) {
  kde <- kde * 1e9  # Scaling the values
}

```

Plot to see if rescaling makes sense
```{r }
tm_shape(kde) + 
  tm_raster("ud") +
  tm_layout(main.title = "Kernel Density Estimate", main.title.position = "center")

```

Overlay findings back to main map
creates a bounding box based on the extents of the Output.Areas polygon
```{r }
bounding_box <- bb(MergedGeo3)

```

Maps the raster within the bounding box
```{r }
tm_shape(kde, bbox = bounding_box) + tm_raster("ud")

```

Mask the raster by the output area polygon
```{r }
masked_kde <- mask(kde, MergedGeo3)

```

Maps the masked raster, also maps white output area boundaries
```{r }
tm_shape(masked_kde, bbox = bounding_box) + tm_raster("ud", style = "quantile", n = 5, legend.show = TRUE, palette = "YlGnBu") +
  tm_shape(MergedGeo3) + tm_borders(alpha=.3, col = "black") +
  tm_layout(frame = TRUE)

```

We can also use bespoke symbols for distilleries locations
```{r }
iconfile1 <- download.file("https://www.iconarchive.com/download/i123361/pictogrammers/material/bottle-tonic.512.png", destfile = "icon1.png", mode = "wb")
icon1 <- readPNG('icon1.png')

```

Plot again
```{r }
spplot(MergedGeo3,
       "per", 
       col.regions = color.palette3(100),
       main = "Booze Reports",
       key.space = "right",
       sp.layout = list("sp.polygons",
                        PointsDistilleries,
                        col = "black", pch = "icon1", labels = PointsDistilleries$Name, cex = 2),
       scales = list(draw = TRUE))

```

### Exercise 
Try another symbol yourself that looks more like a wine bottle maybe! Also try to add a scale bar and a north arrow
Write your code below
```{r }

```

Solution 
```{r }
## Check dimensions of the boundary box to help guide where to put the labels
MergedGeo3@bbox 

## Code for scale bar (you could adjust size of text just like how you can adjust the size of symbols)
scalebar <- list("SpatialPolygonsRescale", layout.scale.bar(), scale = 100000, fill = c("transparent", "black"), offset = c(50000, 1100000))

text1 <- list("sp.text", c(50000, 1120000), "0km", cex = 0.7)
text2 <- list("sp.text", c(150000, 1120000), "25km", cex = 0.7)

## Code for north arrow
arrow <- list("SpatialPolygonsRescale", layout.north.arrow(), offset = c(50000, 1150000), scale = 45000)
geo3_layout <- list(c("sp.polygons",
                      PointsDistilleries,
                      col = "black", pch = 19, labels = PointsDistilleries$Name), scale, text1, text2, arrow)

geo3_layout <- list(
  list("sp.polygons", PointsDistilleries, col = "black", pch = 19, labels = PointsDistilleries$Name), 
  scalebar, 
  text1, 
  text2, 
  arrow
)

## Code for adding everything to the map
spplot(MergedGeo3,
       "per", 
       col.regions = color.palette3(100),
       sp.layout = geo3_layout,
       scales = list(draw = TRUE)
)

```
